---
title:  "자료구조"
search: true
categories: 
  - Coding
  - Computer Science
  - Data Structure
toc: true
toc_sticky: true
last_modified_at: 2023-03-16T17:12:00
---

# 기본 자료 구조들

## 자료 구조란?

* 자료 구조: 데이터의 효율적인 접근 및 조작을 가능하게 하는 저장 및 관리 방식

## 컴퓨터가 데이터를 저장하는 방법

* 데이터가 저장하는 곳
  * 스토리지(Storage): 데이터가 영구적으로 저장되는 곳
    * 데이터를 저장하는 데 오래 걸린다.
    * 데이터를 받아오는 데 오래 걸린다.
  * 메모리(Memory): 데이터가 임시로 저장되는 곳 ⇒ 메모리
    * 데이터를 저장하는 데 빠르다.
    * 데이터를 받아오는 데 빠르다.
* 메모리
  * 일정한 칸으로 나누어져 있다.
  * 각 칸에 데이터를 저장할 수 있다.
  * 각 칸에는 자신만의 주소가 있다.
* RAM(Random Access Memory): 임의 접근 메모리
  * 임의 접근: 접근 위치를 알면 접근할 때 항상 일정한 시간이 걸림
  * 메모리에 저장한 데이터 접근 시간 복잡도: $$O(1)$$
  * cf. 순차 접근: 저장된 위치까지 가는데 한 단계씩 거쳐야 함. 임의 접근이 순차 접근보다 효율적이다!
* 자료 구조
  * 메모리에 데이터를 저장한다.
  * 메모리에 저장된 데이터를 찾는다.
  * → 임의 접근으로 하고 있다: $$O(1)$$
* 메모리 한 칸이 저장할 수 있는 가장 기본적인 용량의 단위: 바이트(byte)
* 레퍼런스(Reference)
  * 데이터에 접근할 수 있게 해주는 값
  * "주소"보다 조금 더 포괄적, 추상적인 표현
  * 자료 구조를 배울 때는 "주소=레퍼런스"라고 생각해도 됨
  * 실제로 변수를 사용할 때는 저장된 값을 알아서 받아옴
* `id`함수: 데이터의 메모리 주소를 정수로 표현한 값을 출력
  * Aliasing: 여러 변수가 같은 메모리를 가리키는 것
    `list2 = list1`

## 배열
* C 배열
  * 크기가 고정되어 있다.
  * 같은 타입의 데이터만 담을 수 있다.
  * 데이터가 메모리에 연속적으로 저장
* 파이썬 리스트
  * 각 데이터의 레퍼런스를 저장. 각각의 레퍼런스는 각 데이터를 갖게 됨. ⇒ 다양한 타입 저장 가능
  * 데이터 메모리에 항상 연속적으로 저장 X

<br>

* **배열**
  * 배열의 요소들이 메모리에 순서대로, 그리고 연속적으로 저장
  * 인덱스 주소: 시작 주소 + 데이터 크기 × 인덱스
  * 배열 인덱스 접근: 주소를 알면 $$O(1)$$으로 접근 가능(임의 접근)
  * 배열 탐색: 선형 탐색 시간 복잡도 $$O(n)$$
  * 배열의 종류
    * 정적 배열: 크기 고정(요소 수 제한) ⇒ 보통 배열이라 칭함
      * 부족하게 잡으면: 더 넣을 공간 부족
      * 넉넉하게 잡으면: 공간 낭비
    * 동적 배열(Dynamic Array): 크기 변함(요소 계속 추가 가능)
      * 정적 배열로 만들어진 자료 구조
      * 정적 배열의 크기를 상황에 맞게 조절
      * 파이썬 등 동적 배열을 자료형으로 제공하는 대부분의 언어는 실제 사용하는 배열의 크기와 상관없이 저장해놓은 공간만 사용할 수 있게 처리되어 있음(index를 넘어서는 값에 접근하면 error가 나도록 의도적으로 처리)
  * **추가 연산(append operation)**

    |정적 배열 남는 공간 있을 때|정적 배열이 꽉 찼을 때|
    |:---:|:---:|
    |자주 발생|가끔 발생|
    |$$O(1)$$|$$O(n)$$|
    |-|1. 2배로 큰 메모리를 새로 예약 <br> 2. 본래 가지고 있는 데이터를 복사($$O(n)$$) <br> 3. 새 데이터 추가 |

    ※ 분할 상환 분석(Amortized Analysis)
      * 같은 동작을 $$n$$번 했을 때 드는 시간이 $$X$$일 때 동작을 한 번 하는데 걸린 시간: $$\frac{X}{n}$$

      1. 새로운 데이터를 동적 배열 맨 끝에 단순히 저장하는 데 걸리는 시간 <br>
        ⇒ 인덱스에 데이터를 저장하는 데 걸리는 시간 1 → 이 행동을 $$n$$번 → $$O(n)$$
      2. 더 큰 배열을 만들고 그 배열에 기존의 데이터를 옮기는 데 걸리는 시간 <br>
        ⇒ 추가 연산을 $$n$$번 했을 때, 가장 마지막에 데이터를 $$m$$개 옮겼다고 가정 → $$m + \frac{m}{2} + \frac{m}{4} + \cdots + 1 = 2m - 1 (m < n)$$ <br>
        ⇒ 연속으로 추가 연산을 $$n$$번 하면 데이터를 옮겨서 저장하는 데 걸리는 총 시간은 $$2n$$보다 작다.
      3. 1과 2에 의해 총 드는 시간은 $$3n$$보다 적은 시간
        ⇒ $$\therefore O(3n) = O(n)$$
      4. 연속으로 $$n$$번 수행하는 작업이므로 분할 상환 분석에 의하여 $$\frac{O(n)}{n} = O(1)$$
      5. 따라서, 동적 배열의 추가(append) 연산은 최악의 경우 <span style="color: red"> $$O(n)$$ </span> 이고, 분할 상환 분석을 하면 <span style="color: red"> $$O(1)$$ </span>이다.

      * 최악의 경우보다 분할 상환 분석을 한 시간 복잡도가 더 적으면 분할 상환 분석을 한 시간 복잡도를 사용
    
  * **삽입 연산(insert operation)**(동적 배열)
    * 배열의 임의의 공간에 투입

    |정적 배열 남는 공간 있을 때|정적 배열이 꽉 찼을 때|
    |:---:|:---:|
    |최악의 상황은 가장 처음에 삽입|복사 + 자리 생성|
    |$$O(n+1) = O(n)$$|$$O(2n+1)=O(n)$$|

    * 삽입 연산 시간 복잡도: <span style="color: red"> $$O(n)$$ </span>
  
  * **삭제 연산**(동적 배열)
    * 최악의 경우: 맨 앞 데이터를 지울 때 $$O(n)$$ → 이런 상황이 잦으면 동적 배열은 비효율적
    * 맨 뒤 데이터를 지울 때 $$O(1)$$
    * 동적 배열 크기 줄이기
      1. 특정 비율 이하로 떨어지면 새로운 내부 배열을 정의
      2. 기존의 요소를 새로 만든 내부 배열에 옮겨서 저장
      * 동적 배열 맨 끝에 데이터 삭제 시간 복잡도
        * 최악의 경우: 새 배열 복사 ⇒ <span style="color: red">  $$O(n)$$ </span>
        * 분할 상환 분석: 대부분 $$O(1)$$, 드물게 $$O(n)$$ ⇒ <span style="color: red"> $$O(1)$$ </span>
  
  * **(정리)** 배열 vs 동적 배열
    * 시간 복잡도

      ||배열|동적 배열|
      |:---:|:---:|:---:|
      |접근(access)|$$O(1)$$|$$O(1)$$|
      |탐색(search)|$$O(n)$$|$$O(n)$$|
      |삽입(insert)|불가|$$O(n)$$<br> 맨뒤 $$O(1)$$|
      |삭제(delete)|불가|$$O(n)$$<br> 맨뒤 $$O(1)$$|

    * 낭비 공간
      * 배열: 크기가 고정되어 있기 때문에 낭비하는 공간이 없다.
      * 동적 배열: 공간을 낭비할 수도 있고 안 할 수도 있다.
        * 최악의 경우 → 새로운 배열을 만들었을 때 $$O(n-2)$$




