---
title:  "알고리즘"
search: true
categories: 
  - Coding
  - Computer Science
  - Algorithm
toc: true
toc_sticky: true
last_modified_at: 2023-03-16T15:20:00
---

# 좋은 알고리즘이란?

## 알고리즘이란?

* 컴퓨터 알고리즘: 컴퓨터가 어떤 문제를 해결하기 위해서 컴퓨터가 이해할 수 있는 방식으로 정리되어 있는 해결 방법

## 하나의 문제, 여러 가지 알고리즘

* 탐색: 저장된 정보들 중에서 원하는 값을 찾는 것
  1. 선형 탐색 알고리즘(linear search algorithm)
    * 정렬이 된 리스트

      ```python
      def linear_search(element, some_list):
        for i in range(len(some_list)):
          if some_list[i] == element:
            return i
        return None
      ```

  2. 이진 탐색 알고리즘(binary search algorithm)
    * data가 기하급수적으로 클 때

      ```python
      def binary_search(element, some_list):
        start_index = 0
        end_index = len(some_list) - 1

        while start_index <= end_index:
          midpoint = (start_index + end_index) // 2
          if some_list[midpoint] == element:
            return midpoint
          elif some_list[midpoint] > element:
            end_index = midpoint - 1
          else:
            start_index = midpoint + 1
        return None
      ```
<br>

* 정렬(Sorting): 리스트의 원소들을 특정 순서로 정리하는 것
  1. 선택 정렬(Selection Sort): 각 위치에 어떤 값이 들어갈지 찾는다.
  2. 삽입 정렬(Insertion Sort): 각 값이 어떤 위치에 들어갈지 찾는다.
  * 정렬 문제: 절대적인 좋은 답 없음
    * 거의 정렬된 리스트: 삽입 정렬(Insertion Sort). 가장 빠름
    * 무작위 순서의 리스트: 힙 정렬(Heapsort)
    * 반대로 정렬된 리스트: 삽입 정렬(Insertion Sort). 가장 느림
    * 선택 정렬(Selection Sort), 합병 정렬(Merge Sort): 상황에 영향을 받지 않고 일정한 시간이 소요

## 알고리즘 평가법

* 시간 복잡도(Time Complexity)
  * 점근 표기법(Big-O)
    1. 선형 탐색과 이진 탐색

        ||선형 탐색|이진 탐색|
        |:---:|:---:|:---:|
        |최고의 경우|$$O(1)$$|$$O(1)$$|
        |최악의 경우|$$O(n)$$|$$O(\lg n)$$|

    2. List Operations

        |Operation|Code|Average Case|
        |:---:|:---:|:---:|
        |인덱싱|`list[index]`|$$O(1)$$|
        |정렬|`list.sort()`<br>`sorted(list)`|$$O(n\lg n)$$|
        |뒤집기|`list.reverse()`|$$O(n)$$|
        |탐색|`element in list`|$$O(n)$$|
        |끝에 요소 추가|`list.append(element)`|$$O(1)$$|
        |중간에 요소 추가|`list.insert(index, element)`|$$O(n)$$|
        |삭제|`del list[index]`|$$O(n)$$|
        |최솟값, 최댓값 찾기|`min(list)`<br>`max(list)`|$$O(n)$$|
        |길이 구하기|`len(list)`|$$O(1)$$|
        |슬라이싱|`list[a:b]`|$$O(b-a)$$|

    3. Dictionary Operations

        |Operation|Code|Average Case|
        |:---:|:---:|:---:|
        |값 찾기|`dict[key]`|$$O(1)$$|
        |값 넣어주기/찾아주기|`dict[key] = value`|$$O(1)$$|
        |값 삭제|`del dict[key]`|$$O(1)$$|

    * $$O(1)$$: input의 크기가 소요 시간에 영향 X
    * $$O(n)$$: 반복문 횟수가 input의 크기에 비례
    * $$O(n^2)$$: 반복문 내부에 반복문. 둘 다 input의 크기에 비례
    * $$O(n^3)$$: input의 크기에 비례하는 반복문이 3번 중첩
    * $$O(\lg n)$$: $$i$$가 두 배씩 증가, 반씩 감소
    * $$O(n\lg n)$$: $$O(n)$$과 $$O(\lg n)$$이 겹쳐진 것
  
<br>
  
* 공간 복잡도(Time Complexity)
  * input 크기에 비례해서 알고리즘이 사용하는 메모리 공간
  * Big-O 표기법 사용 가능
  
<br>
  
* 유용한 파이썬 기능 정리
  * `type`: parameter의 data type이 return. $$O(1)$$
  * `max`, `min`: 가장 큰 값 혹은 작은 값. $$O(n)$$
  * `str`: 숫자를 문자열로. 시간 복잡도는 자릿수에 비례($$O(\lg n)$$)
  * `append`: $$O(1)$$
  * `insert`, `del`, `index`, `reverse`: $$O(n)$$
  * `sort`, `sorted`: sort는 리스트 자체를 정렬, sorted는 정렬된 새로운 리스트를 return. $$O(n\lg n)$$
  * `list[a:b]`: 리스트의 일부를 받아올 수 있음. $$O(b-a)$$
  * `len`: 리스트, 사전, 문자열 등의 길이를 return. $$O(1)$$

<br>

# 재귀 함수

## 재귀 함수

* 재귀(Recursion)
* 재귀 함수(Recursive Function): 자기 자신을 호출하는 함수
* 재귀적으로 문제를 푼다는 것
  * 같은 형태의 더 작은 문제(부분 문제(Subproblem))를 풀고 부분 문제의 답을 이용해서 기존 문제를 푸는 것
  * ex> $$n!$$($$n$$ 팩토리얼)

    ||||
    |:---:|:---:|:---:|
    |$$n=0$$인 경우|$$n!=1$$|base case|
    |$$n>0$$인 경우|$$n!=(n-1)!\times n$$|recursive case|

    ```python
    def factorial(n):
      if n == 0:
        return 1
      return factorial(n-1) * n
    ```
  
  * 재귀 함수 호출이 많으면 call stack이 많이 쌓여 과부하

## 재귀 함수 연습

* 피보나치 수열: 시간 복잡도 $$O(2^n)$$

  ```python
  def fib(n):
    # base case
    if n < 3:
      return 1
    
    # recursive case
    return fib(n-1) + fib(n-2)
  ```

<br>

# 알고리즘 패러다임

## Brute Force

* Brute-Force Attack: 무차별 대입 공격
* Brute Force의 장점
  * 직관적이고 명확하다.
  * 답을 확실하게 찾을 수 있다.
* Brute Force 알고리즘은 비효율적
* Input이 엄청 클 경우? ⇒ 효율적인 알고리즘의 첫 시작은 Brute Force

## Divide and Conquer

* Divide and Conquer(분할 정복)
  1. Divide
  2. Conquer → Divide, Conquer, Combine ...
  3. Combine
* Merge Sort(합병 정렬)
  1. Divide: 리스트를 반으로 나눈다.
  2. Conquer: 왼쪽 리스트와 오른쪽 리스트를 각각 정렬한다.
  3. Combine: 정렬된 두 리스트를 하나의 정렬된 리스트로 합병한다.

    ```python
    def merge(list1, list2):
      i = 0
      j = 0

      merged_list = []

      while i < len(list1) and j < len(list2):
        if list1[i] > list2[j]:
          merged_list.append(list2[j])
          j += 1
        else:
          merged_list.append(list1[i])
          i += 1
      
      return merged_list + list1[i:] + list2[j:]
    
    def merge_sort(my_list):
      if len(my_list) < 2:
        return my_list

      left_half = my_list[:len(my_list) // 2]
      right_half = my_list[len(my_list) // 2:]

      return merge(merge_sort(left_half), merge_sort(right_half))
    ```

* Quick Sort(퀵 정렬)
  * pivot 기준으로 작은 값은 좌측, 큰 값은 우측으로 정렬
  * partition: 그룹 4개로 분류.
    1. Pivot: 기준점
    2. Small: Pivot보다 작음
    3. Big: Pivot보다 큼
    4. Unknown: 아직 모름

    * 과정

      1. Unknown, Big은 start에서 시작, Pivot은 end에서 시작
      2. Unknown이 Pivot보다 크면 Unknown + 1
      3. Unknown이 Pivot보다 작으면 Big과 Unknown이 있는 자리 바꾸고 Unknown, Big + 1
      4. Unknown이 Pivot의 위치와 같아지면 Big과 Pivot의 위치 바꾸고 종료
  
  ```python

  def quicksort(my_list, start = 0, end = None):
    if end == None:
      end = len(my_list) - 1
    
    if start >= end:
      return my_list
    
    mid = partition(my_list, start, end)
    quicksort(my_list, start, mid - 1)
    quicksort(my_list, mid + 1, end)

  def partition(my_list, start, end):
    b = start
    i = start
    p = end

    while(i < p):
      if my_list[i] < my_list[p]:
        my_list[i], my_list[b] = my_list[b], my_list[i]
        b += 1
      i += 1
    my_list[p], my_list[b] = my_list[b], my_list[p]
    return b
  ```

## Dynamic Programming

* Dynamic Programming의 조건
  1. 최적 부분 구조(Optimal Substructure)
    * 부분 문제들의 최적의 답을 이용해서 기존 문제의 최적의 답을 구할 수 있다는 것
    * ex> 피보나치, 최단 경로 찾기(이전 부분 문제의 최적의 경로를 찾고, 그 이후부터 최저의 경로를 찾기)
  2. 중복되는 부분 문제(Overlapping Subproblems)
    * 같은 것을 여러 번 해결할 때
* 최적 부분 구조가 있다 → 기존 문제를 부분 문제로 나눠서 풀 수 있다 → 중복되는 부분 문제들이 있을 수 있다 ⇒ Dynamic Programming
* 한 번 계산한 결과를 재활용하는 방식
* 방법
  1. Memoization: 중복되는 계산은 한 번만 계산 후 메모
    * 하향식 접근(Top-down Approach)
    * 재귀
    
    ```python
    def fib_memo(n, cache):
      if not n in cache:
        if n < 3:
          cache[n] = 1
        else:
          cache[n] = fib_memo(n-1, cache) + fib_memo(n-2, cache)
      return cache[n]
  
    def fib(n):
      fib_cache = {}

      return fib_memo(n, fib_cache)
    ```
  
  2. Tabulation: Table 방식으로 정리
    * 상향식 접근(Bottom-up Approach)
    * 반복문

    ```python
    def fib_tab(n):
      table = [0, 1, 1]

      for i in range(3, n+1):
        table.append(table[i-1] + table[i-2])

      return table[n]
    ```

    ** 시간 복잡도 $$O(n)$$, 공간 복잡도 $$O(n)$$
      but, 이전 값과 현재 값만 저장하면 공간 최적화($$O(1)$$), 모든 계산값을 저장할 필요가 없다면 공간 사용을 최적화!
    
    ```python
    def fib_optimized(n):
      previous = 0
      current = 1

      for i in range(2, n+1):
        current, previous = current + previous, current
      
      return current
    ```

* Memoization과 Tabulation의 공통점과 차이점

  <table>
    <tr bgcolor = "#e9dcbe" style = "text-align: center; border-bottom: 2px solid #afa58f">
      <th> </th>
      <th class="text-center"> Memoization </th>
      <th class="text-center"> Tabulation </th>
    </tr>
    <tr align = "center">
      <td> 공통점 </td>
      <td colspan = "2"> 둘 다 중복되는 부분 문제의 비효율을 해결 </td>
    </tr>
    <tr align = "center">
      <td rowspan = "2"> 차이점 </td>
      <td> 재귀 → 재귀의 문제점과 동일(memory overflow) </td>
      <td> memory overflow 문제점 X </td>
    </tr>
    <tr align = "center">
      <td> 필요없는 계산 안해도됨 </td>
      <td> 필요없는 계산까지 할 가능성 높음 </td>
    </tr>
  </table>

## Greedy Algorithm

* 미래를 내다보지 않고, 당장 눈 앞에 보이는 최적의 선택을 하는 방식
* 장점: 간단하고 빠르다.
* 단점: 최적의 답이 보장되지 않는다.
* 사용하는 때: 최적의 답이 필요 없을 때, 기존 알고리즘이 너무 느릴 때
* Greedy Algorithm이 최적의 답을 보장해 주는 문제도 있다.
  * 최적 부분 구조(Optimal Substructure)
  * 탐욕적 선택 속성(Greedy Choice Property): 각 단계에서 탐욕스런 선택이 최종 답을 구하기 위한 최적의 선택

<br>

# 문제 해결 능력 기르기

<details>
<summary> <b>투자 귀재 규식이 II</b> </summary>
<div markdown = "1">
  <br>
  규식이는 친구들 사이에서 투자의 귀재로 알려져 있습니다. 페이수북과 인수타그램에 자신의 성과를 과시하기 때문인데요. 사실 규식이가 그 정도의 실력자는 아닙니다. 성과가 좋을 때에만 SNS에 공유해서 그렇게 비춰질 뿐이죠. 계속해서 멋진 모습을 보여주기 위해, 특정 기간 중 수익이 가장 큰 구간을 찾아내는 함수 **`sublist_max`**를 작성해 보려고 합니다. Divide and Conquer 방식으로 이 문제를 한 번 풀어봅시다! 시간 복잡도는 $$O(n\lg{n})$$이 되어야 합니다.

  **`sublist_max`** 함수는 3개의 파라미터를 받습니다.

  - **`profits`: 며칠 동안의 수익이 담겨 있는 리스트**
  - **`start`: 살펴볼 구간의 시작 인덱스**
  - **`end`: 살펴볼 구간의 끝 인덱스**

  **`sublist_max`**는 **`profits`**의 **`start`**부터 **`end`**까지 구간에서 가능한 가장 큰 수익을 리턴합니다.

  우선 함수 **`sublist_max`**는 파라미터로 리스트 **`profits`**를 받는데요. **`profits`**에는 며칠 동안의 수익이 담겨 있습니다. 예를 들어서 **`profits`**가 **`[7, -3, 4, -8]`**이라면 첫 날에는 7달러를 벌었고, 둘째 날에는 3달러를 잃었고, 셋째 날에는 4달러를 벌었고, 마지막 날에는 8달러를 잃은 거죠. **`profits`**가 **`[7, -3, 4, -8]`**이라면 무엇을 리턴해야 할까요? **`profits`**에서 가장 많은 수익을 낸 구간은 **`[7, -3, 4]`**입니다. 이 구간에서 낸 수익은 8달러이니, **`8`**을 리턴하면 되겠죠! 만약 **`profits`**가 **`[-2, -3, 4, -1, -2, 1, 5, -3]`**이라면? **`profits`**에서 수익이 가장 큰 구간은 **`[4, -1, -2, 1, 5]`**입니다. 이 구간에서 낸 수익은 7달러이니, **`7`**을 리턴하겠죠?

  합병 정렬을 구현할 때 **`merge_sort`** 함수를 깔끔하게 작성하기 위해 추가로 **`merge`** 함수를 작성했던 것 기억 나시나요? 마찬가지로 퀵 정렬을 구현할 때 **`quicksort`** 함수에 추가로 **`partition`** 함수를 작성했습니다. 이번에도 **`sublist_max`** 함수에 추가로 새로운 함수를 작성하면 도움이 되실 겁니다.

  ```python
  def sublist_max(profits, start, end):
    # 코드를 작성하세요. 

  # 테스트
  list1 = [-2, -3, 4, -1, -2, 1, 5, -3]
  print(sublist_max(list1, 0, len(list1) - 1))

  list2 = [4, 7, -6, 9, 2, 6, -5, 7, 3, 1, -1, -7, 2]
  print(sublist_max(list2, 0, len(list2) - 1))

  list3 = [9, -8, 0, -7, 8, -6, -3, -8, 9, 2, 8, 3, -5, 1, -7, -1, 10, -1, -9, -5]
  print(sublist_max(list3, 0, len(list3) - 1))

  list4 = [-9, -8, -8, 6, -4, 6, -2, -3, -10, -8, -9, -9, 6, 2, 8, -1, -1]
  print(sublist_max(list4, 0, len(list4) - 1))
  ```

<details>
<summary> <b>모범 답안</b> </summary>
<div markdown ="1">

1. 내가 한 풀이 1

    ```python
    def sublist_max(profits, start, end):
        
        # base case
        if start == end:
            return profits[start]
        
        # divide
        mid = (start + end) // 2

        # conquer
        left_max = sublist_max(profits, start, mid)
        right_max = sublist_max(profits, mid + 1, end)

        mid_left_max = profits[mid]
        temp_mid_left_max = profits[mid]
        mid_right_max = profits[mid + 1]
        temp_mid_right_max = profits[mid + 1]

        for i in range(mid - 1, start - 1, -1):
            temp_mid_left_max = temp_mid_left_max + profits[i]
            mid_left_max = max(temp_mid_left_max, mid_left_max)
        
        for i in range(mid + 2, end + 1, 1):
            temp_mid_right_max = temp_mid_right_max + profits[i]
            mid_right_max = max(temp_mid_right_max, mid_right_max)
        
        mid_max = mid_left_max + mid_right_max

        # combine
        return max(left_max, right_max, mid_max)
    ```

2. 내가 한 풀이2

    ```python
    def max_crossing_sum(profits, start, end):
        mid = (start + end) // 2
        max1 = profits[mid]
        sum1 = max1
        max2 = profits[mid+1]
        sum2 = max2
        for i in range(mid - 1, start - 1, -1):
            sum1 = sum1 + profits[i]
            max1 = max(sum1, max1)
        for i in range(mid + 2, end + 1):
            sum2 = sum2 + profits[i]
            max2 = max(sum2, max2)
        return max1 + max2

    def sublist_max(profits, start, end):
        if start < end:
            mid = (start + end) // 2
            left_max = sublist_max(profits, start, mid)
            right_max = sublist_max(profits, mid + 1, end)
            return max(left_max, right_max, max_crossing_sum(profits, start, end))
        else:
            return profits[start]
    ```

3. 모범답안

    ```python
    def max_crossing_sum(profits, start, end):
        mid = (start + end) // 2      # 중간 인덱스

        '''
        왼쪽에서의 가장 큰 수익 계산
        인덱스 mid부터 인덱스 0까지 범위를 넓혀가며 최대 수익을 찾는다
        '''
        left_sum = 0                  # 왼쪽 누적 수익
        left_max = profits[mid]       # 왼쪽 최고 수익; 왼쪽 반 중 가장 오른쪽 값으로 초기화

        for i in range(mid, start - 1, -1):
            left_sum += profits[i]
            left_max = max(left_max, left_sum)

        '''
        오른쪽에서의 가장 큰 수익 계산
        인덱스 mid+1부터 인덱스 end까지 범위를 넓혀가며 최대 수익을 찾는다
        '''
        right_sum = 0                 # 오른쪽 누적 수익
        right_max = profits[mid + 1]  # 오른쪽 최고 수익; 오른쪽 반 중 가장 왼쪽 값으로 초기화

        for i in range(mid + 1, end + 1):
            right_sum += profits[i]
            right_max = max(right_max, right_sum)

        return left_max + right_max


    def sublist_max(profits, start, end):
        # 범위에 하나의 항목밖에 없으면, 그 항목을 리턴한다
        if start == end:
            return profits[start]

        # 중간 인덱스
        mid = (start + end) // 2

        # 상황별로 최대 수익을 구한다
        max_left = sublist_max(profits, start, mid)
        max_right = sublist_max(profits, mid + 1, end)
        max_cross = max_crossing_sum(profits, start, end)

        # 위 세 경우 중 가장 큰 결괏값을 리턴한다
        return max(max_left, max_right, max_cross)
    ```

</div>
</details>

</div>
</details>

<details>
<summary> <b>투자 귀재 규식이 III</b> </summary>
<div markdown = "1">
  <br>
  이미 sublist_max 함수를 Divide and Conquer 방식으로 작성했는데요. 이번 과제에서는 시간 복잡도를 $$O(n)$$로 한 번 더 단축해보세요! 과제 설명은 ‘투자 귀재 규식이 II’를 참고하세요!

  ```python
  def sublist_max(profits):
    # 코드를 작성하세요.
      
  # 테스트
  print(sublist_max([7, -3, 4, -8]))
  print(sublist_max([-2, -3, 4, -1, -2, 1, 5, -3, -1]))
  ```

<details>
<summary> <b>모범 답안</b> </summary>
<div markdown ="1">

1. 내가 한 풀이 1

    ```python
    def sublist_max(profits):
    previous_max = profits[0]
    current_max = profits[0]

    for profit in profits[1:]:
        if profit >= 0:
            if current_max < 0:
                current_max = profit
            else:
                current_max += profit
            if previous_max < current_max:
                previous_max = current_max
        else:
            current_max += profit
    
    return previous_max
    ```

2. 내가 한 풀이2

    ```python
    def sublist_max(profits):
    max_profit_so_far = profits[0]
    max_check = profits[0]
    
    for i in range(1, len(profits)):
        max_check = max(max_check + profits[i], profits[i])
        max_profit_so_far = max(max_profit_so_far, max_check)
    
    return max_profit_so_far
    ```

3. 모범답안

    1. **힌트 1**
    
        아래 리스트를 예시로 생각을 해 봅시다.
        
        ```
        profits = [7, -3, 4, -8]
        
        ```
        
        **`profits`**의 최대 수익은 아래 두 가지 중 하나입니다.
        
        1. **부분 문제 `[7, -3, 4]`의 최대 수익 (`sublist_max([7, -3, 4])`)**
        2. **부분 문제 `[7, -3, 4, -8]`에서 `8` 을 포함한 구간의 최대 수익**
        
        첫 번째 경우는 당연하죠? 최대 수익 구간에 마지막 요소가 포함되지 않을 때 최대 수익은 부분 문제와 똑같습니다.
        
        두 번째 경우는 첫 번째와는 반대되는 경우인데요. 마지막 요소 **`-8`**가 포함돼서 최대 수익이 기존 값에서 변하는 경우죠. **`-8`**가 포함되는 구간은 **`-8`**이 포함된 구간들은 총 네 개의 구간이 있습니다.
        
        1. **`[-8]`**
        2. **`[4, -8]`**
        3. **`[-3, 4, -8]`**
        4. **`[7, -3, 4, -8]`**
        
        이 구간들에서 나올 수 있는 최대 수익이 바로 마지막 요소 **`-8`**가 포함된 경우의 최대 수익이죠.
        
        첫 번째 경우는:
        
        ```python
        max_profit_so_far = sublist_max([7, -3, 4])
        ```
        
        두 번째 경우는:
        
        ```python
        max_check = max(sum([-8]), sum([4, -8]), sum([-3, 4, -8]), sum([7, -3, 4, -8]))
        ```
        
        이렇게 표현할 수 있겠네요.
      
    2. **힌트 2**
        
        **`sublist_max(profits)`**는,
        
        1. **`max_profit_so_far = sublist_max([7, -3, 4])`**
        2. **`max_check = max(sum([-8]), sum([4, -8]), sum([-3, 4, -8]), sum([7, -3, 4, -8]))`**
        
        이 두 값 중 더 큰 값이고, 코드로 나타내면,
        
        ```python
        max_profit_so_far = max(max_profit_so_far, max_check)
        ```
        
        이렇게 표현할 수 있습니다. For 문을 돌면서 각 요소까지의  **`max_profit_so_far`**과 **`max_check`**를 효율적으로 구할 수 있는 방법에 대해서 생각해보세요.
        
    3. **힌트 3**
        
        두 정보 다 바로 전 부분 문제에서 받아올 수 있는 정보를 이용해서 효율적으로 알아낼 수 있는데요.
        
        **`max_profit_so_far = sublist_max([7, -3, 4])`** 이 정보는 바로 전 요소까지의 부분 문제의 답을 그대로 쓰면 되겠죠?
        
        **`max_check`**도 마찬가지인데요.
        
        **`max_check_1 = max(sum([-8]), sum([4, -8]), sum([-3, 4, -8]), sum([7, -3, 4, -8]))`**를 하나하나 계산할 필요 없이, 바로 전 부분 문제에서 계산한 **`max_check_2 = max(sum([4]), sum([-3, 4]), sum([7, -3, 4]))`**을 구했을 때의 값 저장해놓았으면,
        
        ```python
        max_check_1 = max(max_check_2 - 8, -8)
        ```
        
        이렇게 구할 수 있겠죠?
        
    4. **정답**

        ```python
        def sublist_max(profits):
          max_profit_so_far = profits[0] # 반복문에서 현재까지의 부분 문제의 답
          max_check = profits[0] # 가장 끝 요소를 포함하는 구간의 최대 합
          
          # 반복문을 통하여 각 요소까지의 최대 수익을 저장한다
          for i in range(1, len(profits)):
              # 새로운 요소를 포함하는 구간의 최대합을 비교를 통해 정한다
              max_check = max(max_check + profits[i], profits[i])
              
              # 최대 구간 합을 비교를 통해 정한다
              max_profit_so_far = max(max_profit_so_far, max_check)
          
          return max_profit_so_far
        ```

</div>
</details>

</div>
</details>

<details>
<summary> <b>중복되는 항목 찾기 II</b> </summary>
<div markdown = "1">
  <br>
  $$(N + 1)$$의 크기인 리스트에, 1부터 N까지의 임의의 자연수가 요소로 할당되어 있습니다. 그렇다면 어떤 수는 꼭 한 번은 반복되겠지요.

  예를 들어 **`[1, 3, 4, 2, 5, 4]`**와 같은 리스트 있을 수도 있고, **`[1, 1, 1, 6, 2, 2, 3]`**과 같은 리스트가 있을 수도 있습니다. (몇 개의 수가 여러 번 중복되어 있을 수도 있습니다.)

  이러한 리스트에서 반복되는 요소를 찾아내려고 합니다.

  중복되는 어떠한 수 ‘하나’만 찾아내도 됩니다. 즉 **`[1, 1, 1, 6, 2, 2, 3]`**의 예시에서 1, 2를 모두 리턴하지 않고, 1 또는 2 하나만 리턴하게 하면 됩니다.

  저번 과제에서는 사전을 정의해서 문제를 푸는 방법을 사용했는데요, 이번 과제에서는 두 가지의 제약이 있습니다.

  1. $$**O(n)$$ 이상의 공간을 사용할 수 없습니다. 즉 사전이나 리스트와 같이 인풋 리스트의 길이에 비례하는 공간 저장 도구를 사용할 수 없습니다!**
  2. **인풋으로 받는 리스트 `some_list`의 요소들을 바꾸거나 변형할 수 없습니다.**

  **전에 풀었던 같은 문제를 다른 제약들이 걸려 있는 상황에서 풀어보세요.**

  ```python
  def find_same_number(some_list, start, end):
    # 필요한 경우, start와 end를 옵셔널 파라미터로 만들어도 됩니다.
    # 코드를 쓰세요


  # 중복되는 수 ‘하나’만 리턴합니다.
  print(find_same_number([1, 4, 3, 5, 3, 2]))
  print(find_same_number([4, 1, 5, 2, 3, 5]))
  print(find_same_number([5, 2, 3, 4, 1, 6, 7, 8, 9, 3]))
  ```

<details>
<summary> <b>모범 답안</b> </summary>
<div markdown ="1">

1. 내가 한 풀이 1

    ```python
    def find_same_number(some_list):
    start = 1
    end = len(some_list) - 1

    while(start != end):
        mid = (start + end) // 2
        lower = 0
        upper = 0

        for num in some_list:
            if mid + 1 <= num <= end:
                upper += 1
            elif start <= num <= mid:
                lower += 1

        if lower > mid - start + 1:
            end = mid
        elif upper > end - mid:
            start = mid + 1
        
    return start
    ```

2. 내가 한 풀이2

    ```python
    def find_same_number(some_list, start = 1, end = -1):
    if end == -1:
        end = len(some_list) - 1
    
    if (start == end):
        return start
    mid = (start + end) // 2
    count = 0
    for i in some_list:
        if (start <= i <= mid):
            count += 1
    if (count > mid - start + 1):
        return find_same_number(some_list, start, mid)
    else:
        return find_same_number(some_list, mid+1, end)
    ```

3. 모범답안

    1. **힌트 1**
        
        이진 탐색 알고리즘 기억나시나요?
        
        정렬된 리스트에서 특정 값을 찾고 싶을 때 리스트의 탐색 범위를 반씩 줄여나가면서 리스트 안에 값이 있는지 확인하는 알고리즘인데요.
        
        이진 탐색과 비슷하게 중복되는 요소 탐색 범위를 반씩 줄여나갈 수 있는 방식이 있는지 한 번 고민해보세요.
        
    2. **힌트 2**
        
        **`number_array = [1, 2, 4, 6, 2, 5, 3]`** 이 리스트를 인풋이라고 생각해봅시다. 길이가 7인 리스트에 1부터 6까지의 자연수들이 들어있는데요. 중복되는 요소가 1부터 3까지의 범위에 있는지  4부터 6까지의 범위에 있는지 알 수 있는 방법을 생각해보세요.
        
    3. **힌트 3**
        
        다시 **`number_array = [1, 2, 4, 6, 2, 5, 3]`** 를 살펴봅시다.
        
        리스트 안에 숫자는 7개고 이 7개의 숫자가 1 ~ 6까지의 자연수일 수 있으니까 범위 1 ~ 3에 있는 숫자가 4개 이상이거나 범위 4 ~ 6에 있는 숫자가 4개 이상일 수밖에는 없겠죠?
        
        (두 범위가 모두 4보다 작은 것은 말이 안 되죠. 숫자는 7개이고 1 ~ 3인 숫자가 3개 이하고 4 ~ 6인 숫자도 3개 이하면 절대 총 숫자가 7개가 될 수 없기 때문입니다.)
        
        그럼 1 ~ 3 범위에 속하는 숫자가 4개 이상이라면 1 ~ 3 범위에는 적어도 한 숫자는 다시 반복되는 요소일 수밖에 없겠네요. 숫자는 4개인데 요소가 될 수 있는 자연수는 1, 2, 3 세 개밖에는 없으니까요. 반대로 4 ~ 6 범위에 속하는 숫자가 4개 이상일 때도 동일합니다.
        
        기존 탐색 범위를 1~6에서 1~3 또는 4~6로  줄일 수 있군요! 범위를 계속 줄이면 결국 답을 찾을 수 있겠죠?
        
    4. **힌트 4**
        
        아직 좀 이해하시기 힘드시다면, 실제로 반복되는 숫자를 찾는 예시를 통해 차근차근 알아봅시다.
        
        **`number_array = [1, 2, 4, 6, 2, 5, 3]`** 일 경우를 생각해봅시다.
        
        1. **1 ~ 3 범위에 있는 자연수의 갯수: 4개, 4 ~ 6 범위에 있는 자연수의 갯수: 3개**
        
        → 1 ~ 3 범위에 반복되는 자연수가 있을 수밖에 없다.
        
        1. **1 범위에 있는 자연수의 갯수: 1개, 2 ~ 3 범위에 있는 자연수의 갯수: 3개**
        
        → 2 ~ 3 범위에 반복되는 자연수가 있을 수밖에 없다
        
        1. **2 범위에 있는 자연수의 갯수: 2개 → 반복되는 숫자 2을 찾았다 (끝)**
        
        이런 식으로 반복되는 숫자를 찾을 수 있습니다!
        
        *위 방식대로 반복되는 숫자를 찾는 코드를 써볼까요?*
        
    5. **정답**

        ```python
          def find_same_number(some_list, start = 1, end = None):
              if end == None:
                  end = len(some_list)

              # 반복 요소를 찾으면 리턴한다
              if start == end:
                  return start

              # 중간 지점을 구한다
              mid = (start + end) // 2

              # 왼쪽 범위의 숫자를 센다. 오른쪽은 리스트 길이에서 왼쪽 길이를 빼면 되기 때문에 세지 않는다
              left_count = 0

              for element in some_list:
                  if start <= element and element <= mid:
                      left_count += 1

              # 왼쪽과 오른쪽 범위중 과반 수 이상의 숫자가 있는 범위 내에서 탐색을 다시한다
              if left_count > mid - start + 1:
                  return find_same_number(some_list, start, mid)

              return find_same_number(some_list, mid + 1, end)

          print(find_same_number([1, 4, 3, 5, 3, 2]))
          print(find_same_number([4, 1, 5, 2, 3, 5]))
          print(find_same_number([5, 2, 3, 4, 1, 6, 7, 8, 9, 3]))
        ```

</div>
</details>

</div>
</details>